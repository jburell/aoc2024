#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!fsharp

#r "nuget: FSharpplus" 
#r "nuget: FParsec"
open FSharpPlus
open FParsec

#!fsharp

let spacesOnly: Parser<unit, unit> =
  many1Satisfy (fun c -> c = ' ') >>% ()

let strLine: Parser<int list, unit> =
  sepBy pint32 spacesOnly

let getLines: Parser<int list list, unit> =
  sepEndBy strLine newline 

let extract runner = 
  match (runner getLines) with
  | Success(value, _, _) -> value
  | Failure(err, _, _) -> err |> exn |> raise

#!fsharp

// Calculate the answer

type Direction = Up of int | Down of int

let calcDir (v: int): Direction =
  match v with
  | v when v < 0 -> Up v
  | _ -> Down v

let dirIsSame dir1 dir2: bool =
  match dir1, dir2 with
  | Up _, Up _ -> true
  | Up _, Down _ -> false
  | Down _, Down _ -> true
  | Down _, Up _ -> false

let safeDistance dist =
  dist <= 3 && dist <> 0

let safeDirection (dir1: Direction) (dir2: Direction option): bool =
  if dir2.IsSome 
  then dirIsSame dir1 dir2.Value 
  else true

let countErrors state distance direction: int =
  Seq.fold (fun acc ok -> if not ok then acc + 1 else acc) 0 [state; distance; direction]

let isSafe allowedErrors (line: int list): bool =
  List.fold (fun (acc: bool * Direction option * int) item ->
    let (state, dir, last) = acc
    let diff = last - item
    let direction = (calcDir diff)
    if state
    then 
      let distance = abs(diff)
      //printfn "state: %A, last: %d, item: %d, dir: %A, distance: %d" state last item dir distance
      if (countErrors state (safeDistance distance) (safeDirection direction dir)) <= allowedErrors
      then (true, Some direction, item) 
      else (false, Some direction, item)
    else (false, Some direction, item)
    ) (true, None, line.Head) line.Tail
  |> fun s ->
    //printfn "%A" s
    let (a, _, _) = s
    a

let calculate allowedErrors data = 
  data
  |> Seq.map (fun (line: int list) -> isSafe allowedErrors line)  
  |> Seq.fold (fun acc item -> if item then acc + 1 else acc) 0 

let calculateAnswer runner calc = 
  extract runner |> calc

#!fsharp

let inputExample = """7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9"""

let exampleExpected = 2

let stringRunner s parser = runParserOnString parser () "" s

#!fsharp

// Example proof #1
let exampleActual = calculateAnswer (stringRunner inputExample) (calculate 0)
printfn "Example #1: expexted: %d, actual: %d" exampleExpected exampleActual 

#!fsharp

// Calculate the exercises

let fileRunner filename parser = runParserOnFile parser () filename Encoding.ASCII

let part1Actual: int = calculateAnswer (fileRunner "data/input2a.txt") (calculate 0)
printfn "Part 1: %d" part1Actual

// TODO: Fix. Still too high. Need to alter algorithm.
let part2Actual: int = calculateAnswer (fileRunner "data/input2b.txt") (calculate 1)
printfn "Part 2: %d" part2Actual
